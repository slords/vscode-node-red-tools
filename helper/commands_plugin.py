"""
Plugin-related command implementations for vscode-node-red-tools

Contains commands for plugin management: creating new plugins and listing plugins.
"""

import importlib.util
from pathlib import Path

from .logging import log_info, log_success, log_warning, log_error
from .config import load_config
from .plugin_loader import extract_numeric_prefix, DEFAULT_PLUGIN_PRIORITY


def new_plugin_command(name: str, plugin_type: str, priority: int = None) -> int:
    """Generate a new plugin scaffold"""
    try:
        # Determine priority if not specified
        if priority is None:
            # Auto-assign priority based on type
            type_priorities = {
                "pre-explode": 100,
                "explode": 200,
                "post-explode": 300,
                "pre-rebuild": 400,
                "post-rebuild": 500,
            }
            priority = type_priorities.get(plugin_type, DEFAULT_PLUGIN_PRIORITY)

        # Generate class name (PascalCase)
        class_name = "".join(word.capitalize() for word in name.split("_"))
        if not class_name.endswith("Plugin"):
            class_name += "Plugin"

        # Generate filename
        filename = f"{priority}_{name.lower()}_plugin.py"

        # Check if file exists
        plugins_dir = Path(__file__).parent.parent / "plugins"
        output_path = plugins_dir / filename

        if output_path.exists():
            log_error(f"Plugin file already exists: {output_path}")
            return 1

        # Generate plugin code
        plugin_code = _generate_plugin_template(class_name, plugin_type, priority)

        # Write file
        output_path.write_text(plugin_code)

        log_success(f"Created plugin: {output_path}")
        log_info(f"  Class name: {class_name}")
        log_info(f"  Type: {plugin_type}")
        log_info(f"  Priority: {priority}")
        log_info("\nNext steps:")
        log_info(f"  1. Edit {output_path}")
        log_info("  2. Implement the plugin logic")
        log_info("  3. Test with: python vscode-node-red-tools.py list-plugins")

        return 0

    except Exception as e:
        log_error(f"Plugin generation failed: {e}")
        import traceback

        traceback.print_exc()
        return 1


def _generate_plugin_template(class_name: str, plugin_type: str, priority: int) -> str:
    """Generate plugin template code"""
    # Convert type to human-readable description
    type_descriptions = {
        "pre-explode": "modifies flows JSON before exploding",
        "explode": "extracts node data to files",
        "post-explode": "formats files after exploding",
        "pre-rebuild": "processes files before rebuilding",
        "post-rebuild": "formats flows JSON after rebuilding",
    }
    description = type_descriptions.get(plugin_type, "processes nodes")

    template = f'''"""
{class_name} - {description}

This plugin {description}.
Generated by: python vscode-node-red-tools.py new-plugin
"""

from pathlib import Path
from typing import List
import sys
import os

# Add parent directory to path to import Plugin base class
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from helper import Plugin


class {class_name}(Plugin):
    """
    {class_name} - {description}

    Priority: {priority}
    Type: {plugin_type}
    """

    def get_name(self) -> str:
        return "{class_name.replace("Plugin", "").lower()}"

    def get_priority(self) -> int:
        return {priority}

    def get_plugin_type(self) -> str:
        return "{plugin_type}"
'''

    # Add type-specific template methods
    if plugin_type == "pre-explode":
        template += '''
    def process_flows_pre_explode(self, flow_data: list, repo_root: Path) -> list:
        """
        Modify flow data before exploding.

        Args:
            flow_data: List of flow nodes
            repo_root: Repository root directory

        Returns:
            Modified flow_data
        """
        # TODO: Implement your pre-explode logic here
        # Example: Normalize node IDs, validate structure, etc.

        return flow_data
'''

    elif plugin_type == "explode":
        template += '''
    def can_handle_node(self, node: dict) -> bool:
        """
        Return True if this plugin will process this node.

        Args:
            node: Node dictionary

        Returns:
            True if this plugin handles this node type
        """
        # TODO: Implement your node type detection
        # Example: return node.get("type") == "my-custom-type"

        return False

    def get_claimed_fields(self, node: dict) -> List[str]:
        """
        Return list of node fields this plugin will modify.

        Args:
            node: Node dictionary

        Returns:
            List of field names (e.g., ["func", "info"])
        """
        # TODO: Return fields that this plugin extracts to files
        # Example: return ["myfield", "myotherfield"]

        return []

    def explode_node(self, node: dict, node_dir: Path, repo_root: Path) -> List[str]:
        """
        Explode node-specific files.

        Args:
            node: Node dictionary
            node_dir: Directory for this node's files
            repo_root: Repository root directory

        Returns:
            List of created filenames (relative to node_dir)
        """
        # TODO: Implement file extraction logic
        # Example:
        # node_id = node["id"]
        # content = node.get("myfield", "")
        # output_path = node_dir / f"{node_id}.myext"
        # output_path.write_text(content)
        # return [f"{node_id}.myext"]

        return []

    def rebuild_node(
        self, node_id: str, node_dir: Path, skeleton: dict, repo_root: Path
    ) -> dict:
        """
        Rebuild node data from files.

        Args:
            node_id: Node ID
            node_dir: Directory containing this node's files
            skeleton: Skeleton node dictionary
            repo_root: Repository root directory

        Returns:
            Dictionary to merge into node (e.g., {"myfield": "value"})
        """
        # TODO: Implement file loading logic
        # Example:
        # file_path = node_dir / f"{node_id}.myext"
        # if file_path.exists():
        #     content = file_path.read_text()
        #     return {"myfield": content}

        return {}
'''

    elif plugin_type == "post-explode":
        template += '''
    def process_directory_post_explode(
        self, src_dir: Path, flows_path: Path, repo_root: Path
    ) -> bool:
        """
        Process files after exploding (e.g., formatting).

        Args:
            src_dir: Source directory containing exploded files
            flows_path: Path to flows.json file
            repo_root: Repository root directory

        Returns:
            True if changes were made, False otherwise
        """
        # TODO: Implement post-explode processing
        # Example: Format code files, validate structure, etc.
        # Return True if you modified any files

        return False
'''

    elif plugin_type == "pre-rebuild":
        template += '''
    def process_directory_pre_rebuild(self, src_dir: Path, repo_root: Path) -> bool:
        """
        Process files before rebuilding (e.g., validation).

        Args:
            src_dir: Source directory containing files to rebuild
            repo_root: Repository root directory

        Returns:
            True if changes were made, False otherwise
        """
        # TODO: Implement pre-rebuild processing
        # Example: Validate files, check syntax, etc.
        # Return True if you modified any files

        return False
'''

    elif plugin_type == "post-rebuild":
        template += '''
    def process_flows_post_rebuild(self, flows_path: Path, repo_root: Path) -> bool:
        """
        Process flows.json after rebuilding (e.g., formatting).

        Args:
            flows_path: Path to flows.json file
            repo_root: Repository root directory

        Returns:
            True if changes were made, False otherwise
        """
        # TODO: Implement post-rebuild processing
        # Example: Format JSON, validate structure, etc.
        # Return True if you modified the flows file

        return False
'''

    return template


def list_plugins_command(
    repo_root: Path,
    plugins_dict: dict = None,
    plugin_config: dict = None,
) -> int:
    """List all available plugins with their status and priority

    Args:
        repo_root: Repository root path
        plugins_dict: Pre-loaded plugins dictionary (shows actual loaded state)
        plugin_config: Pre-loaded plugin configuration
    """
    try:
        log_info("Available plugins:")

        # Load config if not provided
        if plugin_config is None:
            config = load_config(repo_root, config_path=None)
            plugin_config = config.get("plugins", {})
        else:
            plugin_config = plugin_config.get("plugins", {})

        enabled_list = plugin_config.get("enabled", [])
        disabled_list = plugin_config.get("disabled", [])
        config_order = plugin_config.get("order", [])

        # Get actually loaded plugin names (from CLI overrides)
        loaded_plugin_names = set()
        if plugins_dict:
            for plugin_list in plugins_dict.values():
                loaded_plugin_names.update(p.get_name() for p in plugin_list)

        # Get plugins directory (parent.parent because we're in helper/ subdirectory)
        plugins_dir = Path(__file__).parent.parent / "plugins"

        if not plugins_dir.exists():
            log_warning("No plugins directory found")
            return 0

        # Load all plugin modules (without filtering)
        all_plugins = []

        for plugin_file in sorted(plugins_dir.glob("*_plugin.py")):
            try:
                # Load the module
                spec = importlib.util.spec_from_file_location(
                    plugin_file.stem, plugin_file
                )
                if spec and spec.loader:
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)

                    # Find plugin class
                    for name in dir(module):
                        obj = getattr(module, name)
                        if (
                            isinstance(obj, type)
                            and name.endswith("Plugin")
                            and name not in ["Plugin"]
                        ):
                            # Instantiate plugin
                            plugin_instance = obj()
                            plugin_name = plugin_instance.get_name()
                            plugin_type = plugin_instance.get_plugin_type()

                            # Determine priority
                            priority = plugin_instance.get_priority()
                            if priority is None:
                                priority = extract_numeric_prefix(plugin_file.name)

                            # Determine status (use actual loaded state if available)
                            if plugins_dict:
                                # Use actual loaded state (from CLI overrides)
                                status = (
                                    "loaded"
                                    if plugin_name in loaded_plugin_names
                                    else "not loaded"
                                )
                            elif enabled_list:
                                # If enabled list is specified, only those are enabled
                                status = (
                                    "enabled"
                                    if plugin_name in enabled_list
                                    else "disabled"
                                )
                            elif plugin_name in disabled_list:
                                status = "disabled"
                            else:
                                status = "enabled"

                            # Check if in config order
                            order_position = None
                            if plugin_name in config_order:
                                order_position = config_order.index(plugin_name) + 1

                            all_plugins.append(
                                {
                                    "name": plugin_name,
                                    "type": plugin_type,
                                    "priority": priority,
                                    "filename": plugin_file.name,
                                    "status": status,
                                    "order_position": order_position,
                                }
                            )
                            break

            except Exception as e:
                log_warning(f"Failed to load plugin {plugin_file.name}: {e}")

        # Group plugins by type
        plugin_types = [
            "pre-explode",
            "explode",
            "post-explode",
            "pre-rebuild",
            "post-rebuild",
        ]
        plugins_by_type = {t: [] for t in plugin_types}

        for p in all_plugins:
            plugin_type = p.get("type", "unknown")
            if plugin_type in plugins_by_type:
                plugins_by_type[plugin_type].append(p)

        # Sort each group by priority
        for plugins in plugins_by_type.values():
            plugins.sort(key=lambda x: x["priority"])

        # Print each section
        print()
        total_enabled = 0
        total_disabled = 0

        for plugin_type in plugin_types:
            plugins = plugins_by_type[plugin_type]
            if not plugins:
                continue

            # Section header
            print(f"\n{plugin_type.upper()} ({len(plugins)} plugins)")
            print("-" * 101)
            print(
                f"{'Plugin Name':<30} {'Priority':<10} {'Status':<14} {'Order':<9} {'Filename':<30}"
            )
            print("-" * 101)

            for p in plugins:
                order_str = (
                    str(p["order_position"]) if p["order_position"] is not None else "-"
                )
                status_symbol = "✓" if p["status"] in ["enabled", "loaded"] else "✗"
                # Status field: symbol (1) + space (1) + status text (12) = 14 total
                print(
                    f"{p['name']:<30} {p['priority']:<10} {status_symbol} {p['status']:<12} {order_str:<9} {p['filename']:<30}"
                )

                if p["status"] in ["enabled", "loaded"]:
                    total_enabled += 1
                elif p["status"] in ["disabled", "not loaded"]:
                    total_disabled += 1

        print()
        log_info(
            f"Total: {len(all_plugins)} plugins ({total_enabled} enabled, {total_disabled} disabled)"
        )

        return 0

    except Exception as e:
        log_error(f"List plugins failed: {e}")
        import traceback

        traceback.print_exc()
        return 1
